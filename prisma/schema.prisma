generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  telegramId    String?  @unique
  walletAddress String   @unique
  username      String?
  balance       Float    @default(0)
  createdAt     DateTime @default(now())
  solanaWallet  String?
  bscWallet     String?
  trades        Trade[]  @relation("UserTrades")

  @@map("users")
}

model Market {
  id              String    @id @default(uuid())
  externalId      String    @unique
  question        String
  eventTime       DateTime
  forecast        Float?
  poolYes         Float
  poolNo          Float
  status          String    @default("open")
  onchainId    BigInt?  //
  feeCollected    Float     @default(0)
  createdAt       DateTime  @default(now())
  notified        Boolean   @default(false)
  settledAt       DateTime?
  expiresAt       DateTime?
  houseProfit     Float?
  tag             String?
  updatedAt       DateTime  @updatedAt
  resolved        Boolean   @default(false)
  resolvedOutcome String?
  description     String?
  outcomes        Outcome[]
  trades          Trade[]

  @@map("markets")
}

model Outcome {
  id       String  @id @default(cuid())
  marketId String
  name     String
  market   Market  @relation(fields: [marketId], references: [id])
  trades   Trade[] @relation("OutcomeTrades")

  @@map("outcomes")
}

model Trade {
  id        String   @id @default(cuid())
  marketId  String
  userId    String
  type      String
  amount    Float
  fee       Float
  payout    Float
  shares    Float
  settled   Boolean  @default(false)
  createdAt DateTime @default(now())
  outcomeId String?
  won       Boolean?
  market    Market   @relation(fields: [marketId], references: [id])
  outcome   Outcome? @relation("OutcomeTrades", fields: [outcomeId], references: [id])
  user      User     @relation("UserTrades", fields: [userId], references: [id])

  @@index([marketId])
  @@index([userId])
  @@map("trades")
}

model Deposit {
  txHash      String
  createdAt   DateTime @default(now())
  address     String
  amount      String
  blockNumber Int
  chainId     Int
  id          Int      @id @default(autoincrement())

  @@map("deposits")
}

model Withdrawal {
  id        String   @id @default(cuid())
  userId    String
  chain     String
  amount    Float
  nonce     String   @unique
  expiresAt DateTime
  status    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  txHash    String?

  @@index([userId])
  @@map("withdrawals")
}

model DepositAddress {
  id              Int              @id @default(autoincrement())
  chainId         Int
  address         String           @unique
  lastBalance     String
  onChainDeposits OnChainDeposit[] @relation("AddressDeposits")

  @@map("deposit_addresses")
}

model OnChainDeposit {
  id             Int            @id @default(autoincrement())
  chainId        Int
  address        String
  amount         String
  txHash         String         @unique
  blockNumber    Int
  createdAt      DateTime       @default(now())
  status         String
  depositAddress DepositAddress @relation("AddressDeposits", fields: [address], references: [address])

  @@map("onchain_deposits")
}

model Subscriber {
  id         String   @id @default(cuid())
  chatId     String   @unique
  subscribed Boolean
  createdAt  DateTime @default(now())

  @@map("subscribers")
}
